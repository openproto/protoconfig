package main

import (
	"fmt"

	protoconfig "github.com/openproto/protoconfig/go"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	bytesPackage      = protogen.GoImportPath("bytes")
	fmtPackage        = protogen.GoImportPath("fmt")
	ioPackage         = protogen.GoImportPath("io")
	protoPackage      = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protojsonPackage  = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	openConfigPackage = protogen.GoImportPath("github.com/openproto/protoconfig/go")
)

// generateGoProtoConfig generates a _protoconfig.pb.go file containing a code of Congfigurator and Configurable (based on https://github.com/urfave/cli/), based
// ProtoConfig 1.0 specification.
func generateGoProtoConfig(gen *protogen.Plugin, file *protogen.File) error {
	var (
		ocEntryPoints []*protoconfig.Metadata
		fEntryPoints  []*protogen.Message
	)

	for _, f := range file.Messages {
		e := proto.GetExtension(f.Desc.Options().(*descriptorpb.MessageOptions), protoconfig.E_Metadata)
		c, ok := e.(*protoconfig.Metadata)
		if !ok {
			return fmt.Errorf("unexpected type; got %T expected protoconfig.Configuration", e)
		}
		// Such extension is not specified.
		if c == nil {
			continue
		}

		ocEntryPoints = append(ocEntryPoints, c)
		fEntryPoints = append(fEntryPoints, f)
	}

	if len(ocEntryPoints) == 0 {
		// Nothing to generate.
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_protoconfig.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-protoconfig code. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	// NOTE: Imports will be added automatically by protogen.

	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the ProtoConfig golang package it is being compiled against.")
	g.P("const _ = ", openConfigPackage.Ident("SupportPackageIsVersion1"))
	g.P()

	// Configure nice helpers for oneofs. Always missing in default protogen-go.
	// TODO(bwplotka): Upstream this idea.
	dup := map[string]struct{}{}
	for _, f := range file.Messages {
		generateOneOfHelper(g, f, dup)
	}

	for i, c := range ocEntryPoints {
		generateConfiguratorSide(g, c, fEntryPoints[i])
		generateConfigurableSide(g, c, fEntryPoints[i])
	}
	return nil
}

func generateOneOfHelper(g *protogen.GeneratedFile, root *protogen.Message, dup map[string]struct{}) {
	for _, o := range root.Oneofs {
		for _, f := range o.Fields {
			helper := "New" + f.Message.GoIdent.GoName
			if _, ok := dup[helper]; ok {
				continue
			}
			dup[helper] = struct{}{}

			g.P("func ", helper, "(x *", f.Message.GoIdent, ") *", f.GoIdent, " {")
			g.P("return &", f.GoIdent, "{", f.GoName, ": x}")
			g.P("}")
			g.P()
		}
	}
	for _, m := range root.Messages {
		generateOneOfHelper(g, m, dup)
	}
}
func generateConfiguratorSide(g *protogen.GeneratedFile, c *protoconfig.Metadata, root *protogen.Message) {
	g.P("// Encode encodes self as `Encoded Configuration Message` in proto format so it can be understood and")
	g.P("// passed to Configurable struct. It supports all `Proto Config Extensions Format 1.0` extenstion")
	g.P("// (validation, default values etc).")
	g.P("// Use `proto.Marshal` encoding without `ProtoConfig 1.0` extension support.")
	g.P("func (x *", root.GoIdent.GoName, ") Encode() ([]byte, error) {")
	g.P("// TODO(bwplotka): Actually implement validation for `Proto Config Extensions Format 1.0` (: ")
	g.P("return ", protoPackage.Ident("Marshal"), "(x)")
	g.P("}")
	g.P()
	// TODO(bwplotka): Ideally get this from interface comment directly? (parse interface code?)
	g.P("// EncodeJSON encodes self as `Encoded Configuration Message` in JSON format so it can be understood and")
	g.P("// passed to Configurable struct. It supports all `Proto Config Extensions Format 1.0` extenstion")
	g.P("// (validation, default values etc).")
	g.P("// Use `protojson.Marshal` encoding without `ProtoConfig 1.0` extension support.")
	g.P("func (x *", root.GoIdent.GoName, ") EncodeJSON() ([]byte, error) {")
	g.P("// TODO(bwplotka): Actually implement validation for `Proto Config Extensions Format 1.0` (: ")
	g.P("return ", protojsonPackage.Ident("Marshal"), "(x)")
	g.P("}")
	g.P()
	g.P("// Metadata returns metadata defined in `Proto Config Extensions Format 1.0`.")
	g.P("func (x *", root.GoIdent.GoName, ") Metadata() ", openConfigPackage.Ident("Metadata"), " {")
	// TODO(bwplotka): Generate, but not manually, find better way.
	g.P("return ", openConfigPackage.Ident("Metadata"), "{")
	g.P(`Name: "`, c.Name, `",`)
	g.P(`Version: "`, c.Version, `",`)
	g.P(`Description: "`, c.Description, `",`)
	switch {
	case c.GetFlagDelivery() != nil:
		g.P(`DeliveryMechanism:  &`, openConfigPackage.Ident("Metadata_FlagDelivery"), `{FlagDelivery: &`, openConfigPackage.Ident("FlagDelivery"), `{Name: "`, c.GetFlagDelivery().Name, `"}},`)
	case c.GetStdinDelivery() != nil:
		g.P(`DeliveryMechanism: &`, openConfigPackage.Ident("Metadata_StdinDelivery"), `{StdinDelivery: &`, openConfigPackage.Ident("StdinDelivery"), `{}},`)
	}
	g.P("}")
	g.P("}")
	g.P()

	switch {
	case c.GetFlagDelivery() != nil:
		g.P("func (x *", root.GoIdent.GoName, ") CommandLineArgument() (string, error) {")
		g.P("b, err := x.Encode()")
		g.P("if err != nil {")
		g.P(`return "", err`)
		g.P("}")
		g.P(`return `, fmtPackage.Ident("Sprintf"), `("`, c.GetFlagDelivery().Name, `=%s", b), nil`)
		g.P("}")
		g.P()
	case c.GetStdinDelivery() != nil:
		g.P("func (x *", root.GoIdent.GoName, ") CommandLineInput() (*", ioPackage.Ident("Reader"), ", error) {")
		g.P("b, err := x.Encode()")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("return ", bytesPackage.Ident("NewReader"), "(b), nil")
		g.P("}")
		g.P()
	}

	g.P("// This is a compile-time assertion to ensure that extended ", root.GoIdent, " implements")
	g.P("// ", openConfigPackage.Ident("Configurator"), " interface.")
	g.P("var _ ", openConfigPackage.Ident("Configurator"), " = &", root.GoIdent.GoName, "{}")
	g.P()

}

// While it's not mandatory, ProtoConfig 1.0 generates stub for defining Go CLI application that user might or might not use.
// In order to use it external CLI builder is necessary. For example kingpin.v2 implementation see github.com/openproto/protoconfig/go/kingpinv2.
//
// Such app will be compatible with defined configuration and will output such filled typed after parsing.
func generateConfigurableSide(g *protogen.GeneratedFile, _ *protoconfig.Metadata, root *protogen.Message) {
	g.P("// Decode parses byte slice as `Encoded Configuration Message` in JSON or proto format and unmarshal it on")
	g.P("// the Configurable struct. It supports all `Proto Config Extensions Format 1.0` extenstion")
	g.P("// (validation, default values etc).")
	g.P("// Use `proto.Unmarshal` or `protojson.Unmarshal` for decoding without `ProtoConfig 1.0` extension support.")
	g.P("func (x *", root.GoIdent.GoName, ") Decode(ecm []byte) error {")
	g.P("// TODO(bwplotka): Actually implement validation for `Proto Config Extensions Format 1.0` (: ")
	g.P("if isJSON(ecm) { return ", protojsonPackage.Ident("Unmarshal"), "(ecm, x) }")
	g.P("return ", protoPackage.Ident("Unmarshal"), "(ecm, x)")
	g.P("}")
	g.P()
	g.P("// DecodeString parses string as `Encoded Configuration Message` in JSON or proto format and unmarshal it on")
	g.P("// the Configurable struct. It supports all `Proto Config Extensions Format 1.0` extenstion")
	g.P("// (validation, default values etc).")
	g.P("// Use `proto.Unmarshal` or `protojson.Unmarshal` for decoding without `ProtoConfig 1.0` extension support.")
	g.P("func (x *", root.GoIdent.GoName, ") DecodeString(ecm string) error {")
	g.P("return x.Decode([]byte(ecm))")
	g.P("}")
	g.P()
	g.P("func isJSON(b []byte) bool {")
	g.P("bb := ", bytesPackage.Ident("TrimSpace"), "(b)")
	g.P("if len(bb) == 0 { return false }")
	// TODO(bwplotka): Yolo. Improve.
	g.P("return bb[0] == '{'")
	g.P("}")
	g.P()
	g.P("// This is a compile-time assertion to ensure that extended ", root.GoIdent, " implements")
	g.P("// ", openConfigPackage.Ident("Configurable"), " interface.")
	g.P("var _ ", openConfigPackage.Ident("Configurable"), " = &", root.GoIdent.GoName, "{}")
	g.P()

	// TODO(bwplotka): There are useful cli.App features that users might want to add on its program. Create generic CLI parser.
	// All except changing commands and flags should be accepted as option.
}
