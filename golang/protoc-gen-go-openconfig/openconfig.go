package main

import (
	"github.com/pkg/errors"
	openconfig "github.com/thanos-io/OpenConfig/golang"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	bytesPackage      = protogen.GoImportPath("bytes")
	fmtPackage        = protogen.GoImportPath("fmt")
	osExecPackage     = protogen.GoImportPath("os/exec")
	protoPackage      = protogen.GoImportPath("google.golang.org/protobuf/proto")
	protojsonPackage  = protogen.GoImportPath("google.golang.org/protobuf/encoding/protojson")
	openConfigPackage = protogen.GoImportPath("github.com/thanos-io/OpenConfig/golang")
)

// generateGoOpenConfig generates a _openconfig.pb.go file containing a code of Congfigurator and Configurable (based on https://github.com/urfave/cli/), based
// OpenConfig 1.0 specification.
func generateGoOpenConfig(gen *protogen.Plugin, file *protogen.File) error {
	var (
		ocEntryPoints []*openconfig.Metadata
		fEntryPoints  []*protogen.Message
	)

	for _, f := range file.Messages {
		e := proto.GetExtension(f.Desc.Options().(*descriptorpb.MessageOptions), openconfig.E_Metadata)
		c, ok := e.(*openconfig.Metadata)
		if !ok {
			return errors.Errorf("unexpected type; got %T expected openconfig.Configuration", e)
		}
		// Such extension is not specified.
		if c == nil {
			continue
		}

		ocEntryPoints = append(ocEntryPoints, c)
		fEntryPoints = append(fEntryPoints, f)
	}

	if len(ocEntryPoints) == 0 {
		// Nothing to generate.
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_openconfig.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-openconfig code. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	// NOTE: Imports will be added automatically by protogen.

	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the OpenConfig golang package it is being compiled against.")
	g.P("const _ = ", openConfigPackage.Ident("SupportPackageIsVersion1"))
	g.P()

	// Configure nice helpers for oneofs. Always missing in default protogen-go.
	// TODO(bwplotka): Upstream this idea.
	dup := map[string]struct{}{}
	for _, f := range file.Messages {
		generateOneOfHelper(g, f, dup)
	}

	for i, c := range ocEntryPoints {
		generateConfiguratorSide(g, c, fEntryPoints[i])
		generateConfigurableSide(g, c, fEntryPoints[i])
	}
	return nil
}

func generateOneOfHelper(g *protogen.GeneratedFile, root *protogen.Message, dup map[string]struct{}) {
	for _, o := range root.Oneofs {
		for _, f := range o.Fields {
			helper := "New" + f.Message.GoIdent.GoName
			if _, ok := dup[helper]; ok {
				continue
			}
			dup[helper] = struct{}{}

			g.P("func ", helper, "(x *", f.Message.GoIdent, ") *", f.GoIdent, " {")
			g.P("return &", f.GoIdent, "{", f.GoName, ": x}")
			g.P("}")
			g.P()
		}
	}
	for _, m := range root.Messages {
		generateOneOfHelper(g, m, dup)
	}
}
func generateConfiguratorSide(g *protogen.GeneratedFile, c *openconfig.Metadata, root *protogen.Message) {
	// Generate helpers.
	// User can already use protobuf structs to fill in and generate JSON and protobuf without this plugin.
	// The true value will be for configuration languages like Jsonnet, Cue, etc.

	// TODO(bwplotka): Is this really needed?
	g.P("func (x *", root.GoIdent.GoName, ") Marshal() ([]byte, error) {")
	g.P("return ", protoPackage.Ident("Marshal"), "(x)")
	g.P("}")
	g.P()
	g.P("func (x *", root.GoIdent.GoName, ") MarshalJSON() ([]byte, error) {")
	g.P("return ", protojsonPackage.Ident("Marshal"), "(x)")
	g.P("}")
	g.P()
	g.P("func (x *", root.GoIdent.GoName, ") Metadata() ", openConfigPackage.Ident("Metadata"), " {")
	// TODO(bwplotka): Generate, but not manually, find better way.
	g.P("return ", openConfigPackage.Ident("Metadata"), "{")
	g.P(`Name: "`, c.Name, `",`)
	g.P(`Version: "`, c.Version, `",`)
	g.P(`Description: "`, c.Description, `",`)
	switch {
	case c.GetFlagDelivery() != nil:
		g.P(`DeliveryMechanism:  &`, openConfigPackage.Ident("Metadata_FlagDelivery"), `{FlagDelivery: &`, openConfigPackage.Ident("FlagDelivery"), `{Name: "`, c.GetFlagDelivery().Name, `"}},`)
	case c.GetStdinDelivery() != nil:
		g.P(`DeliveryMechanism: &`, openConfigPackage.Ident("Metadata_StdinDelivery"), `{StdinDelivery: &`, openConfigPackage.Ident("StdinDelivery"), `{}},`)
	}
	g.P("}")
	g.P("}")
	g.P()

	switch {
	case c.GetFlagDelivery() != nil:
		g.P("func (x *", root.GoIdent.GoName, ") NewExecCmd(name string) (*", osExecPackage.Ident("Cmd"), ", error) {")
		g.P("b, err := x.Marshal()")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P(`return `, osExecPackage.Ident("Command"), `(name, `, fmtPackage.Ident("Sprintf"), `("`, c.GetFlagDelivery().Name, `=%s", b)), nil`)
		g.P("}")
		g.P()
		g.P("// This is a compile-time assertion to ensure that extended", root.GoIdent, "implements")
		g.P("// ", openConfigPackage.Ident("Commander"), " interface.")
		g.P("var _ ", openConfigPackage.Ident("Commander"), " = &", root.GoIdent.GoName, "{}")
		g.P()
	case c.GetStdinDelivery() != nil:
		g.P("func (x *", root.GoIdent.GoName, ") NewExecCmd(name string) (*", osExecPackage.Ident("Cmd"), ", error) {")
		g.P("b, err := x.Marshal()")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P("c := ", osExecPackage.Ident("Command"), "(name)")
		g.P("c.Stdin = ", bytesPackage.Ident("NewReader"), "(b)")
		g.P("return c, nil")
		g.P("}")
		g.P()
		g.P("// This is a compile-time assertion to ensure that extended ", root.GoIdent, " implements")
		g.P("// ", openConfigPackage.Ident("Commander"), " interface.")
		g.P("var _ ", openConfigPackage.Ident("Commander"), " = &", root.GoIdent.GoName, "{}")
		g.P()
	}

	g.P("// This is a compile-time assertion to ensure that extended ", root.GoIdent, " implements")
	g.P("// ", openConfigPackage.Ident("Configurator"), " interface.")
	g.P("var _ ", openConfigPackage.Ident("Configurator"), " = &", root.GoIdent.GoName, "{}")
	g.P()

}

// While it's not mandatory, OpenConfig 1.0 generates stub for defining Go CLI application that user might or might not use.
// In order to use it external CLI builder is necessary. For example kingpin.v2 implementation see github.com/thanos-io/OpenConfig/golang/kingpinv2.
//
// Such app will be compatible with defined configuration and will output such filled typed after parsing.
func generateConfigurableSide(g *protogen.GeneratedFile, _ *openconfig.Metadata, root *protogen.Message) {

	// TODO(bwplotka): Is this really needed?
	g.P("func (x *", root.GoIdent.GoName, ") Unmarshal(b []byte) error {")
	g.P("// TODO(bwplotka): Generate code that checks first bytes and guess format from it.")
	g.P("return ", protoPackage.Ident("Unmarshal"), "(b, x)")
	g.P("}")
	g.P()

	g.P("func (x *", root.GoIdent.GoName, ") UnmarshalString(b string) error {")
	g.P("// TODO(bwplotka): Generate code that checks first bytes and guess format from it.")
	g.P("return ", protoPackage.Ident("Unmarshal"), "([]byte(b), x)")
	g.P("}")
	g.P()

	g.P("// This is a compile-time assertion to ensure that extended ", root.GoIdent, " implements")
	g.P("// ", openConfigPackage.Ident("Configurable"), " interface.")
	g.P("var _ ", openConfigPackage.Ident("Configurable"), " = &", root.GoIdent.GoName, "{}")
	g.P()

	// TODO(bwplotka): There are useful cli.App features that users might want to add on its program. Create generic CLI parser.
	// All except changing commands and flags should be accepted as option.
}
