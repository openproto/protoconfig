package main

import (
	"github.com/pkg/errors"
	openconfig "github.com/thanos-io/OpenConfig/golang"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	cliPackage     = protogen.GoImportPath("github.com/urfave/cli/v2")
)

// generateGoOpenConfig generates a _openconfig.pb.go file containing a code of Congfigurator and Configurable (based on https://github.com/urfave/cli/), based
// OpenConfig 1.0 specification.
func generateGoOpenConfig(gen *protogen.Plugin, file *protogen.File) error {
	var (
		ocEntryPoints []*openconfig.Configuration
		fEntryPoints  []*protogen.Message
	)

	for _, f := range file.Messages {
		e := proto.GetExtension(f.Desc.Options().(*descriptorpb.MessageOptions), openconfig.E_Configuration)
		c, ok := e.(*openconfig.Configuration)
		if !ok {
			return errors.Errorf("unexpected type; got %T expected openconfig.Configuration", e)
		}
		// Such extention not specified.
		if c == nil {
			continue
		}

		ocEntryPoints = append(ocEntryPoints, c)
		fEntryPoints = append(fEntryPoints, f)
	}

	if len(ocEntryPoints) == 0 {
		// Nothing to generate.
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_openconfig.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by... another code. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// Register import.
	_ = g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: cliPackage})

	for i, c := range ocEntryPoints {
		if err := generateConfigurator(gen, g, c, fEntryPoints[i]); err != nil {
			return err
		}
		if err := generateConfigurableCLI(gen, g, c, fEntryPoints[i]); err != nil {
			return err
		}
	}
	return nil
}

func generateConfigurator(gen *protogen.Plugin, g *protogen.GeneratedFile, c *openconfig.Configuration, root *protogen.Message) error {
	// Generate helpers. You can already use protobuf structs to fill in and generate YAML, Protobuf.
	return nil
}

// While it's not mandatory, OpenConfig 1.0 generates stub for defining Go CLI application that user might or might not use.
// In order to use it external CLI builder is necesary. For example kingpin.v2 implementation see github.com/thanos-io/OpenConfig/golang/kingpinv2.
//
// Such app will be compatible with defined configuration and will ouput such filled typed after parsing.
func generateConfigurableCLI(gen *protogen.Plugin, g *protogen.GeneratedFile, c *openconfig.Configuration, root *protogen.Message) error {
	// TODO(bwplotka): There are useful cli.App features that users might want to add on its program. All except changing commands and flags should be accepted as option.
	g.P("func NewConfigurable(ctx ", contextPackage.Ident("Context"), ") error {")
	g.P("app := &", cliPackage.Ident("App"), "{")
	g.P("Compiled: time.Now(),")
	if c.Name != "" {
		g.P(`Name: "`, c.Name, `",`)
	} else {
		g.P("Name: ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "Args", GoImportPath: "os"}), "[0],")
	}
	if c.Version != "" {
		g.P(`Version: "`, c.Version, `",`)
	}
	if c.Description != "" {
		g.P(`UsageText: "`, c.Description, `",`)
	}

	// debug(gen, "got %+v %v", c.Name)

	return nil
}
func debug(gen *protogen.Plugin, s string, args ...interface{}) {
	gen.Error(errors.Errorf(s, args...))
}
